= RpcClient Interface
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
SPDX-FileCopyrightText: 2023 Contributors to the Eclipse Foundation

See the NOTICE file(s) distributed with this work for additional
information regarding copyright ownership.

This program and the accompanying materials are made available under
the terms of the Apache License Version 2.0 which is available at
https://www.apache.org/licenses/LICENSE-2.0
 
SPDX-FileType: DOCUMENTATION
SPDX-License-Identifier: Apache-2.0
----

== Overview

`RpcClient` defines a common, language specific interface for method invocation to allow the auto-generation of client-side & server-side code per-language (SDK) in lieu of per platform. 

The API is defined using UML2 notation.

[mermaid]
ifdef::env-github[[source,mermaid]]
----
classDiagram

class RpcClient {
  <<interface>>
  invokeMethod(message: UMessage, responseHandler: ResponseHandler)
}

class ResponseHandler {
  <<interface>>
  onResponse(message : UMessage)
  onError(error: UStatus)
}

RpcClient ..> ResponseHandler
----

All link:../languages.adoc[language-specific uProtocol libraries] *MUST* declare the `RpcClient` interface and its supporting types using appropriate programming language constructs.

NOTE: The data types used in the following sections are defined in link:../basics/README.adoc[uProtocol Basic Types].

[#response-handler]
== ResponseHandler

A client provides a `ResponseHandler` in order to process the outcome of a <<invoke-method, service method invocation>>.

=== OnResponse

An `RpcClient` implementation invokes this method for an RPC _Response_ message that has been received in reply to the client's RPC _Request_ message.

[source]
----
onReceive(message: UMessage)
----

.onReceive Parameters
[width="100%",cols="15%,15%,70%"]
|===
|Parameter | Type | Description

| message
| link:../basics/umessage.adoc[UMessage]
| The response message from the service provider.

|===

[mermaid]
ifdef::env-github[[source,mermaid]]
----
sequenceDiagram

participant H as handler:ResponseHandler
participant R as client:RpcClient

R-)H : onResponse(response: UMessage)
activate H
deactivate H
----

=== OnError

An `RpcClient` implementation invokes this method when the invocation of the method was not successful.

[source]
----
onError(error: UStatus)
----

.onReceive Parameters
[width="100%",cols="15%,15%,70%"]
|===
|Parameter | Type | Description

| error
| link:../basics/error_model.adoc[Error Model]
| Information about the error that has occurred.

|===

[mermaid]
ifdef::env-github[[source,mermaid]]
----
sequenceDiagram

participant H as handler:ResponseHandler
participant R as client:RpcClient

R-)H : onError(error: UStatus)
activate H
deactivate H
----

== RpcClient

[#invoke-method]
=== InvokeMethod

[source]
----
invokeMethod(request: UMessage, handler: ResponseHandler)
----

.Parameters
[#parameters, width="100%",cols="15%,25%,60%"]
|===

| Parameter | Type | Description

| request
| link:../basics/umessage.adoc[UMessage]
| The RPC Request message to send to the service provider.

| handler
| <<response-handler, ResponseHandler>>
| The handler to invoke with the outcome of the RPC call.
|===

RpcClient implementations

* *MUST* fail the given handler with a `UCode.DEADLINE_EXCEEDED` if no corresponding Response message has been received before the Request message expires.
* *MUST* fail the given handler with a `UCode.INVALID_PARAMETER` if the given message is not a link:../basics/uattributes.adoc[valid RPC Request message].
* *MUST* fail the given handler with a `UCode.ALREADY_EXISTS` if a service invocation with the same request message is currently pending and not expired.

[mermaid]
ifdef::env-github[[source,mermaid]]
----
sequenceDiagram

actor C as Client

create participant H as handler:ResponseHandler
C->>H : new()
participant R as RpcClient
C-)R : invoke(request, handler)
activate R
alt invalid request message
R--)H : onError(UStatus(UCode.INVALID_ARGUMENT))
else duplicate request
R--)H : onError(UStatus(UCode.ALREADY_EXISTS))
else
actor S as service provider
R-)S : request message
alt request timed out
R--)H : onError(UStatus(UCode.DEADLINE_EXCEEDED))
else comm_status != OK
S-)R : response message
R--)H : onError(UStatus(comm_status))
else comm_status = OK
S-)R : response message
R--)H : onResponse(UMessage)
end
end
deactivate R
----

=== Implementation

Each link:../languages.adoc[language-specific uProtocol library] *MUST* provide a _default_ implementation of `RpcClient` based on the link:../up-l1/README.adoc[Transport Level API] as follows:

[mermaid]
ifdef::env-github[[source,mermaid]]
----
sequenceDiagram

actor C as Client

create participant H as handler<br>:ResponseHandler
C->>H : new()
participant R as transport based impl<br>:RpcClient
C-)R : invoke(request, handler)
activate R
create participant UL as listener<br>:UListener
R->>UL : new(handler)
participant T as transport<br>:UTransport
R->>T : registerListener(method, reply-to-address, listener)
R->>T : send(request)
activate T
actor S as service provider<br>:UEntity
T-)S : request
deactivate T
deactivate R
S-)T : response
activate T
T-)UL : onReceive(response)
deactivate T
UL-)H : onMessage(response)
----

A link:../upclient.adoc[uPClient library] *MAY* provide additional implementations of `RpcClient` which, for example, take advantage of specific features of the underlying communication protocol.






 
