= Transport & Session Layer (uP-L1)
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
----


Transport & Session Layer is responsible for bidirectional point-2-point communication between uEs. What gets sent between uEs vary considerably depending on the type of payload (Safety, Security, fire & forget, etc...) as well as the deployment environment where the uEs are located (Android, Linux, MCU, etc...). 

The Purpose of this layer of the protocol is to define a common ubiquitous language for sending and receiving a messages in a common way across transports, heterogeneous system the uEs are deployed on, or the programming language used. 

This specification shall define the data models (types) and interfaces.  . 
uProtocol programming language specific libraries (SDKs) declare the transport layer interfaces and define the data model, while transport technologies (ex. Binder, MQTT, Zenoh, SOME/IP, DDS, HTTP, etc...) implement said interfaces per language. 

NOTE: We will define the various interfaces in this specification using pseudo code in lieu of a particular IDL such as protobuf as we expect the implementations of this spec to vary slightly between languages. 

We will use the following terminology during this document:

.API Definition Terminology
[width="80%",cols="20%,80%"]
|===
|Term | Description

| `IN` | Input parameter
| `OUT`| Output parameter
| `IN/OUT` | Input/output parameter
| `&` | Parameter passed by reference
| `Future` | Language specific mechanism to access the result of asynchronous operations, ex. https://en.cppreference.com/w/cpp/thread/future[`std::future`] for C++, https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[`CompletableFuture`] for Java, etc...

|===

 * All APIs that return `Status` *MUST* follow link:../basics/error_model.adoc[uProtocol Error Model]



== Data Model

Data model specifies the various types that are to be declared the SDKs and used by uTransport interface.
These specifications define the ubiquitous language so that they are consistent across languages and transport implementations. 

*NOTE:* Unless otherwise stated, the classification or category for various types (ex. enums vs templates vs classes vs structs vs records, etc..) is not specified and left up to the SDK authors.

* Object oriented programming languages *MUST* use object based types (ex. classes) to represent the types defined in this section unless otherwise stated below

* Variable length types such as C++ `std::string` or Java's `byte[]` *MAY* be replaced for fixed types (ex. `char[]`) where applicable


=== UAttributes

UAttributes hold the metadata for <<UPayload>> as well as the uP-L2 routing information. 

NOTE: uProtocol (uTransport) versioning is managed by the <<UMessageType>>  

 * Type name *MUST* be `UAttributes`
 * *MUST* contain `<<UMessageType>>, <<ID>>, and <<UPriority>>,
 * *MUST* adhere to the additional <<messagetype-requirements>>
 * *MAY* contain <<Sink>>, and <<Time-to-Live (TTL)>> 

.Message Type Specific Requirements
[#messagetype-requirements,width="100%",cols="30%,70%"] 
|===
| <<UMessageType>> | Requirements

| `REQUEST`
a| 
 * *MUST* contain <<Sink>>, and <<Time-to-live (TTL)>>
 * *SHOULD* contain <<Permission Level>>
 * *MAY* contain <<Token>>

| `RESPONSE`
a|
 * *MUST* contain <<Sink>> attributes
 * *MUST* contain the <<Correlation ID>>
 * *MAY* contain <<Communication Status>>

|===


=== UMessageType
Enumeration used to represent the type of uProtocol message. 

 * *MUST* have the attribute name `UMessageType`
 * *MUST* be an enumeration
 * *MUST* use nomenclature definitions from  <<message-type>>
 * *SHOULD* be an enum

.uP-L1 API Definition
[#message-type,width="100%",cols="15%,15%,15%,55%"]

|===
| Type | String | Integer | Description

| *PUBLISH*
| `pub.v1`
|0
|Send a multicast publication (1:many) or 1:1 notification to a topic

| *REQUEST*
| `req.v1`
|1
|Send a request to a topic

| *RESPONSE*
| `res.v1`
|2
|Send a response to a request

|===


=== ID

The ID is used to correlate request and response messages as well as provide timestamp information for message sent or received. The ID is generated by the sender and *MUST* be unique for each message.

* *MUST* adhere to link:../basics/uuid.adoc[uProtocol UUID requirements]
* Variable name *MUST* be `id`


=== UPriority
Type used to define link:../basics/qos.adoc[uProtocol Prioritization classifications]. 

 * Type name *MUST* be `UPriority`
 * *MUST* use nomenclature definitions from  <<priority-levels>>
 * *SHOULD* be an enum

.UPriority Levels
[#priority-levels,width="100%",cols="30%,10%,10%,50%"]
|===
| Type | String | Integer | Description

| *LOW*
|`CS0`
|0
|Low UPriority. No bandwidth assurance

| *STANDARD*
|`CS1`
|1
|Standard, undifferentiated application

| *OPERATIONS*
|`CS2`
|2
|Operations, Administration, and Management

| *MULTIMEDIA STREAMING*
|`CS3`
|3
|Multimedia Streaming

| *REALTIME INTERACTIVE*
|`CS4`
|4
|Realtime Interactive

| *SIGNALING*
|`CS5`
|5
|Signaling

| *NETWORK CONTROL*
|`CS6`
|6
|Network Control

|===


=== Sink

Sink is the destination link:../basics/uri.adoc[UUri] for a message. Sink is used for unicast message types using in notification and RPC patterns.

* Type *MUST* be link:../basics/uri.adoc[UUri] 
* Variable name *MUST* be `sink`


=== Time-to-live (TTL)

How long this message should live for after it was generated (in milliseconds). Event expires when:

stem:[t_current > t_{ce_id} + ce_ttl]

* *MUST* be a positive integer value
* *MUST* fit in a 32-bit integer
* Variable name *MUST* be `ttl`
* When not present, or value is 0, message *MUST NOT* time out


=== Communication Status

Communication error attribute populated by uP-L2 dispatchers only when an error has occurred in the delivery of RPC request or response events.
The contents of this attribute, if present, is the unsigned integer representation of https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto[google.rpc.Code]

* *MUST* be a positive integer value
* *MUST* fit in a 32-bit integer
* Variable name *MUST* be `commstatus`


=== Permission Level
Source (senders) uE permission level as defined in link:../up-l2/permissions.adoc#_code_based_access_permissions_caps[Code-Based uE Access Permissions (CAPs)]

* *MUST* be a positive integer value
* *MUST* fit in a 32-bit integer
* Variable name *MUST* be `plevel`


=== Correlation ID

The correlation ID is sent in response messages to correlate to the reque*st. 

* *MUST* adhere to link:../basics/uuid.adoc[uProtocol UUID requirements]
* Variable name *MUST* be `reqid`


=== Token
Access token as defined in per link:../up-l2/permissions.adoc#_token_based_access_permissionstaps[Token-Based uE Access Permissions (TAPs)]

* Variable name *MUST* be `token` 
* *MUST* store the raw token data (ex. bytes) and the size
* *MAY* be of type `String` for Java, or `std::vector<uint8_t>` for C++


=== Serialization Hint

Serialization hint is used to indicate the format of the payload. 

 * Type name *MUST* be `USerializationHint`
 * *MUST* be an enumeration
 * *MUST* use nomenclature definitions from  <<serialization-hint-types>>
 * *SHOULD* be an enum


.Serialization Hint Types
[#serialization-hint,width="100%",cols="20%,35%,10%,40%"]
|===
| Field Name | String | Integer | Description

|UNKNOWN
|`"(empty string)"`
|0
| The serialization hint was not passed or set

|PROTOBUF
|`application/x-protobuf`
|1
|https://developers.google.com/protocol-buffers[Google Protocol Buffers]

|JSON
|`application/json`
|2
|https://www.json.org/[JSON]

|SOMEIP
|`application/x-someip`
|3
|https://www.autosar.org/fileadmin/user_upload/standards/foundation/1-0/AUTOSAR_PRS_SOMEIPProtocol.pdf[SOME/IP]

|RAW
|`application/octet-stream`
|4
|Raw binary data (not serialized)

|===


=== UPayload

UPayload is a container for the uP-L3 application layer data to be transmitted between uEs. The UPayload structure contains only the data and its size. 

If the data is passed by reference (ex. pointer):

* `data` *MUST* contain the pointer to the payload and `size` contains the actual data size

If the data is passed by value (ex. copy):

* `data` *MUST* contains the actual payload

If the programming language `data` type includes the ability to fetch its size (ex. `byte[]`):

* UPayload *MUST NOT* include `size` attributes


=== UListener

`UListener` is an interface used for receiving messages by the client uE from the uTransport layer. Listeners are used for receiving messages asynchronously by the uTransport layer.  

  * Type name *MUST* be `UListener`
  * *MUST* contain the method `UStatus onReceive(link:../basics/uri.adoc[UUri]&, <<UPayload>>&, <<UAttributes>>&)` that is called by the Transport to notify (callback) the client

=== UStatus

An interface used to return the status of the uTransport API calls.

  * Type name *MUST* be `UStatus`
  * *MUST* contain the method `int getCode()` that returns the status code per the link:../basics/error_model.adoc[uProtocol Error Model]
  * *MUST* contain the method `string getMessage()` that returns the status message 



== uTransport Interface

The transport layer API responsible for point-2-point communication. The interface provides common functionality across all transport implementations.

* *MUST* implement all APIs defined in this section

=== Authenticate()

API used to verify the identity of the calling uE by confirming that the passed <<UEntity>> matches that of the transport layer specific identity required for link:../up-l2/permissions.adoc[Code-Based Access Permissions (CAPs)]. 

`OUT <<UStatus>> authenticate(IN <<UEntity>>)`

==== Parameters
.Register Parameters
[width="100%",cols="20%,80%"]
|===
|Parameter | Description

| `UEntity`
| uProtocol UEntity name and version used for identification verification

|===

 * *MUST* be called before any other uTransport APIs
 * *MUST* be idempotent, subsequent calls to the API return the same value
 * *MUST* authenticate client uE identity by ensuring that the <<UEntity>> matches the transport specific identity mechanism. 
 * Non authenticated uEs *MUST* be returned `UNAUTHENTICATED` status code


=== Send()

Publish/send <<UPayload>> and <<UAttributes>> to a link:../basics/uri.adoc[UUri] (topic). 


Communication protocols (a.k.a. uProtocol Transports) define their own Protocol Data Unit (PDU) that comprises of header and payload. Some transports header parameters map already to uProtocol <<UAttributes>>. Sending <<UAttributes>> in the transport's payload as well as in the header increases overhead for little to no gain. To address this issue,  <<Send()>> allows flexibility for uTransport implementers to define however they see fit what gets mapped into their transport header vs payload. 

For example, if HartleyTransport can map only <<UPriority>> to its PDU header, then HartleyTransport would define a PDU payload type that includes <<UPayload>> and all the other <<UAttributes>> and send that new type in its PDU payload such that the receiver will not loose any metadata. 

The API signature:

`OUT <<UStatus>> send(IN/OUT link:../basics/uri.adoc[UUri&], IN <<UPayload>>&, IN <<UAttributes>>&)`

==== Parameters
.Send Parameters
[width="100%",cols="20%,80%"]
|===
|Parameter | Description

| link:../basics/uri.adoc[UUri]

| Destination for the <<UPayload>>

| <<UPayload>>
a| Data to be sent

 * *MUST* be passed by reference

| <<UAttributes>>
a| <<UPayload>> metadata

 * *MUST* be passed by reference

|===

 * All <<UAttribute>> metadata *MUST* be preserved during transmission and available to the receiver
 * *MUST* not manipulate the <<UPayload>> data during transmission
 * Transport *MAY* modify the link:../basics/uri.adoc[UUri&] to set the transportId 

=== RegisterListener()

Register a <<UListener>> to receive message(s) for a given link:../basics/uri.adoc[UUri] (topic). This API is used to implement the _push_ <<Delivery Method>>.

API Signature: 

`OUT <<UStatus>> registerListener(IN link:../basics/uri.adoc[UUri], IN <<UListener>>&)`


 * *MUST* support registering more than one listener per topic
 * *MUST* support registering more than one topic per listener
 * Transport implementations *MUST* declare the maximum number of listeners per topic that it can support. If the maximum number of listeners is reached, the transport *MUST* return `RESOURCE_EXHAUSTED` status code


==== Parameters
.RegisterListener Parameters
[width="100%",cols="20%,80%"]
|===
|Parameter | Description

| link:../basics/uri.adoc[UUri]
| Topic to register the listener for

| <<UListener>>
| Listener to be registered

|===


=== UnregisterListener()

API used to unregister a <<UListener>> for a given topic.

API Signature: 

`OUT <<UStatus>> unregisterListener(IN link:../basics/uri.adoc[UUri], IN <<UListener>>&)`

==== Parameters
.UnregisterListener Parameters
[width="70%",cols="20%,80%"]
|===
|Parameter | Description

| link:../basics/uri.adoc[UUri]
| Topic to unregister the listener for

| <<UListener>>
| Listener to be unregistered

|===


=== Receive()

Implements the _pull_ <<Delivery Method>> to fetch a message from the transport for a given link:../basics/uri.adoc[UUri] (topic).

`OUT <<UStatus>> receive(IN link:../basics/uri.adoc[UUri], OUT <<UPayload>>&, OUT <<UAttributes>>&)`

==== Parameters
.Receive Parameters
[width="100%",cols="20%,80%"]
|===
|Parameter | Description

| link:../basics/uri.adoc[UUri]
| Topic to receive the message from

| <<UPayload>>
a| Data received

 * *MUST* be passed by reference

| <<UAttributes>>
a| Message metadata

 * *MUST* be passed by reference

|===

 * *MUST* return `NOT_FOUND` if there are no messages for the given topic


=== Message Delivery

==== Policy

* Transport *MUST* support https://www.cloudcomputingpatterns.org/at_least_once_delivery/[*At-least-once delivery policy*], this means that a sender *MUST* have a way to guarantee that the CE was successfully received by the Receiver (through the returned <<UStatus>>)
* Transport *MUST* support retransmission of CEs that are no able to be sent

If the uP-L1 transport layer is above https://en.wikipedia.org/wiki/OSI_model[OSI Session layer 5]:

* *MUST* use Transmission Control Protocols (TCP) and *MUST NOT* User Datagram Protocol (UDP) for message delivery

==== Delivery Method

* Transport *MUST* support either _push_ or _pull_ delivery method
* *MAY* support both _push_ or _pull_ CE delivery methods between uEs
* Delivery method *SHOULD* be known by uEs at design time
* Receivers *MAY* select which delivery method they prefer if the transport between sender and receiver supports more than one delivery method

NOTE: Delivery method advertising shall be defined later
