= Transport & Session Layer (uP-L1) Specifications
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
SPDX-FileCopyrightText: 2023 Contributors to the Eclipse Foundation

See the NOTICE file(s) distributed with this work for additional
information regarding copyright ownership.

This program and the accompanying materials are made available under
the terms of the Apache License Version 2.0 which is available at
https://www.apache.org/licenses/LICENSE-2.0
 
SPDX-FileType: DOCUMENTATION
SPDX-License-Identifier: Apache-2.0
----

The Transport & Session Layer is responsible for bidirectional point-2-point communication between uEntities (uE). 
The purpose of this layer of uProtocol is to define a common API for sending and receiving messages across different transport protocols like Eclipse Zenoh, MQTT 5 or Android Binder, runtime environments like Android, Linux or MCUs, and programming languages like Java, Rust, Python or C/C++.

This specification defines the transport layer's abstract API which is mapped to supported programming languages by means of uProtocol's link:../languages.adoc[language specific libraries]. The API is _implemented_ for particular transport protocols and programming languages by link:../upclient.adoc[uProtocol Client libraries].

The Transport Layer API is defined using UML2 notation.

NOTE: The data types used in the following sections are defined in link:../basics/README.adoc[uProtocol Basic Types].

== UListener

A uEntity registers a `UListener` with the transport in order to process (incoming) messages that are of interest to the uEntity.

=== OnReceive

A transport invokes this method for each newly arrived message that matches the criteria specified as part of <<_registerlistener,registering the listener>>.

[source]
----
onReceive(message: UMessage) : Void
----

==== Parameters
.OnReceive Parameters
[width="100%",cols="15%,15%,70%"]
|===
|Parameter | Type | Description

| message
| link:../basics/umessage.adoc[UMessage]
| The newly received message.

|===


== UTransport

This is the main entry point into a transport's messaging functionality.

=== Send

Clients use this method to transmit a single message.

[source]
----
send(message: UMessage) : Future<Void>
)
----

.Send Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| message
| link:../basics/umessage.adoc[UMessage]
| The message to send.

| result
| Future<Void>
| A succeeded future if the message has been sent successfully. This means that the underlying messaging infrastructure has accepted the message for delivery. It does *not* (necessarily) mean that the message has reached its destination (yet). +
Otherwise, a failed future which contains a `UCode` indicating the reason for the failure.
|===

Communication protocols (a.k.a. uProtocol Transports) define their own Protocol Data Unit (PDU) that comprises of header and payload. Some transports header parameters map already to uProtocol UAttributes. Sending UAttributes in the transport's payload as well as in the header increases overhead for little to no gain. To address this issue,  <<Send()>> allows flexibility for uTransport implementers to define however they see fit what gets mapped into their transport header vs payload. 

For example, if HartleyTransport can map only UPriority to its PDU header, then HartleyTransport would define a PDU payload type that includes UPayload and all the other UAttributes and send that new type in its PDU payload such that the receiver will not lose any metadata. 

Implementations

* *MUST* preserve all of the message's meta data during transmission
* *MUST* preserve the message's payload during transmission

=== RegisterListener

Clients use this method to register a listener for messages matching given filter criteria.
This API is used to implement the _push_ <<Delivery Method>> for the underlying messaging infrastructure.
After this method has completed successfully, the given listener will be invoked for each message that matches the given source and sink filter patterns according to the rules defined by the link:../basics/uri.adoc[UUri specification].

[source]
----
registerListener(sourceFilter: UUri, sinkFilter: UUri [0..1], listener: UListener) : Future<Void>
----

.RegisterListener Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The _source_ address pattern that messages need to match.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The _sink_ address pattern that messages need to match. If omitted, a message must not contain any sink address in order to match.

| listener
| <<UListener>>
| The listener to be registered.

| result
| Future<Void>
| A succeeded future if the listener has been registered successfully. +
Otherwise, a failed future which contains a `UCode` indicating the reason for the failure.
|===

Implementations

* *MAY* fail invocations with a `UCode::UNIMPLEMENTED` if the transport does not support the _push_ <<_delivery_method>>. In that case, the <<_unregisterlistener>> method *MUST* also fail accordingly.
* *MUST* support registering more than one listener for any given address patterns
* *MUST* support registering the same listener for multiple address patterns
* *MUST* document the maximum supported number of listeners per address pattern.
* *MUST* fail with a `UCode::RESOURCE_EXHAUSTED`, if the maximum number of listeners is reached

=== UnregisterListener

Clients use this method to unregister a previously registered listener.
The listener will no longer be called for any (matching) messages after this method has returned successfully.

[source]
----
unregisterListener(sourceFilter: UUri, sinkFilter: UUri [0..1], listener: UListener) : Future<Void>
----

.RegisterListener Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The source address pattern that the listener had been registered for.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The sink address pattern that the listener had been registered for.

| listener
| <<UListener>>
| The listener to be unregistered.

| result
| Future<Void>
| A succeeded future if the listener has been unregistered successfully. +
Otherwise, a failed future which contains a `UCode` indicating the reason for the failure.
|===

Implementations

* *MAY* fail invocations with a `UCode::UNIMPLEMENTED` if the transport does not support the _push_ <<_delivery_method>>. In that case, the <<_registerlistener>> method *MUST* also fail accordingly.
* *MUST* fail with a `UCode::NOT_FOUND`, if no such listener had been registered before

=== Receive

Clients use this method to receive a single message matching given filter criteria.
This method implements the _pull_ <<Delivery Method>> for the underlying messaging infrastructure.

[source]
----
receive(sourceFilter: UUri, sinkFilter: UUri [0..1]) : Future<UMessage>
----

.Receive Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The _source_ address pattern that messages need to match.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The _sink_ address pattern that messages need to match. If omitted, a message must not contain any sink address in order to match.

| result
| Future<UMessage>
| A succeeded future containing the least recent message that matches the given filter criteria and has not expired yet. +
Otherwise, a failed future which contains a `UCode` indicating the reason for the failure.

|===

Implementations

* *MAY* fail invocations with a `UCode::UNIMPLEMENTED` if the transport does not support the _pull_ <<_delivery_method>>
* *MUST* fail with a `UCode::NOT_FOUND` if there are no matching messages available

=== Message Delivery

==== Policy

* uTransport `send()` API *MUST* support, meaning the caller of this API is guaranteed the message was successfully delivered to the next-hop only. End-2-end delivery, when messages are sent across multiple transports, is *not* guaranteed by the transport layer
* Transport *MUST* support retransmission of messages that are no able to be delivered to the next-hop

If the uP-L1 transport layer is above https://en.wikipedia.org/wiki/OSI_model[OSI Session layer 5]:

* *MUST* use Transmission Control Protocols (TCP) and *SHOULD NOT* User Datagram Protocol (UDP) for message delivery, this is to ensure https://www.cloudcomputingpatterns.org/at_least_once_delivery/[At-least-once delivery] of messages

==== Delivery Method

* Transport API implementations *MUST* support at least one of _push_ or _pull_ delivery methods and *MAY* support both
* Transport API implementations *MUST* document the delivery methods they support

== Transport Specifics

Below is an non-exhaustive list of transport specific requirements to ensure consistency across implementations of the same or different languages:

* link:binder.adoc[*Android Binder*]
* link:zenoh.adoc[*Eclipse Zenoh*]
* link:ecal.adoc[*Eclipse ECAL*]
* link:p3comm.adoc[*Eclipse P3Comm*]
* link:mqtt.adoc[*MQTT*]
* link:http.adoc[*HTTP*]
* link:someip/README.adoc[*SOME/IP*]

Implementers of `UTransport` *MAY* choose to employ link:https://cloudevents.io/[CloudEvents] as a means to map UMessages to the underlying transport's Packet Data Unit (PDU). In order to provide for consistency across implementations, such transport implementations *MUST* adhere to

* link:cloudevents.adoc[*UMessage mapping to CloudEvents*]
