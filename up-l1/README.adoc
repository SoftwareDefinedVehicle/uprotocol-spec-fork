= Transport & Session Layer (uP-L1) Specifications
:toc:
:sectnums:

The key words "*MUST*", "*MUST NOT*", "*REQUIRED*", "*SHALL*", "*SHALL NOT*", "*SHOULD*", "*SHOULD NOT*", "*RECOMMENDED*", "*MAY*", and "*OPTIONAL*" in this document are to be interpreted as described in https://www.rfc-editor.org/info/bcp14[IETF BCP14 (RFC2119 & RFC8174)]

----
SPDX-FileCopyrightText: 2023 Contributors to the Eclipse Foundation

See the NOTICE file(s) distributed with this work for additional
information regarding copyright ownership.

This program and the accompanying materials are made available under
the terms of the Apache License Version 2.0 which is available at
https://www.apache.org/licenses/LICENSE-2.0
 
SPDX-FileType: DOCUMENTATION
SPDX-License-Identifier: Apache-2.0
----

The Transport & Session Layer is responsible for bidirectional point-2-point communication between uEntities (uE). 
The purpose of this layer of uProtocol is to define a common API for sending and receiving messages across different transport protocols like Eclipse Zenoh, MQTT 5 or Android Binder, runtime environments like Android, Linux or MCUs, and programming languages like Java, Rust, Python or C/C++.

This specification defines the transport layer's abstract API which is mapped to supported programming languages by means of uProtocol's link:../languages.adoc[language specific libraries]. The API is _implemented_ for particular transport protocols and programming languages by link:../upclient.adoc[uProtocol Client libraries].

The Transport Layer API is defined by means of pseudo code using the following terminology:

.API Definition Terminology
[width="80%",cols="20%,80%"]
|===
|Term | Description

| `IN` | Input parameter
| `OUT`| Output parameter
| `&` | Parameter passed by reference
| `?` | Parameter is optional
| `Future<T, E>` | Language specific mechanism to access the result of asynchronous operations, e.g. https://en.cppreference.com/w/cpp/thread/future[`std::future`] for C++, https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletableFuture.html[`CompletableFuture`] for Java etc. +
`T` is the type of the operation's successful outcome. `E` is the type of the operation's erroneous outcome.

|===

NOTE: The data types used in the following sections are defined in link:../basics/README.adoc[uProtocol Basic Types].

== UListener

A uEntity registers a `UListener` with the transport in order to process (incoming) messages that are of interest to the uEntity.

=== OnReceive

A transport invokes this method for each newly arrived message that matches the criteria specified as part of <<_registerlistener,registering the listener>>.

[source]
----
onReceive(IN message: UMessage&)
----

==== Parameters
.OnReceive Parameters
[width="100%",cols="15%,15%,70%"]
|===
|Parameter | Type | Description

| message
| link:../basics/umessage.adoc[UMessage]
| The newly received message.

|===


== UTransport

This is the main entry point into a transport's messaging functionality.

=== Send

Clients use this method to transmit a single message.

[source]
----
send(
  IN message: UMessage&,
  OUT result: Future<Void, UStatus>
)
----

.Send Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| message
| link:../basics/umessage.adoc[UMessage]
| The message to send.

| result
| Future<Void, link:../basics/error_model.adoc[UStatus]>
| A succeeded future if the message has been sent successfully. +
Otherwise, a failed future containing a `UStatus` indicating the reason for the failure.
|===

Communication protocols (a.k.a. uProtocol Transports) define their own Protocol Data Unit (PDU) that comprises of header and payload. Some transports header parameters map already to uProtocol UAttributes. Sending UAttributes in the transport's payload as well as in the header increases overhead for little to no gain. To address this issue,  <<Send()>> allows flexibility for uTransport implementers to define however they see fit what gets mapped into their transport header vs payload. 

For example, if HartleyTransport can map only UPriority to its PDU header, then HartleyTransport would define a PDU payload type that includes UPayload and all the other UAttributes and send that new type in its PDU payload such that the receiver will not loose any metadata. 

[oft-sid="req~utransport-send~1"]
--
Implementations

* *MUST* preserve all of the message's meta data during transmission
* *MUST* preserve the message's payload during transmission
--

=== RegisterListener

Clients use this method to register a listener for messages matching given filter criteria.
This API is used to implement the _push_ <<Delivery Method>> for the underlying messaging infrastructure.
After this method has completed successfully, the given listener will be invoked for each message that matches the given source and sink filter patterns according to the rules defined by the link:../basics/uri.adoc[UUri specification].

[source]
----
registerListener(
  IN sourceFilter: UUri,
  IN sinkFilter: UUri?,
  IN listener: UListener&,
  OUT result: Future<Void, UStatus>
)
----

.RegisterListener Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The _source_ address pattern that messages need to match.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The _sink_ address pattern that messages need to match. If omitted, a message must not contain any sink address in order to match.

| listener
| <<UListener>>
| The listener to be registered.

| result
| Future<Void, link:../basics/error_model.adoc[UStatus]>
| A succeeded future if the listener has been registered successfully. +
Otherwise, a failed future containing a `UStatus` indicating the reason for the failure.
|===

[oft-sid="req~utransport-register-listener~1"]
--
Implementations

* *MUST* support registering more than one listener for any given address patterns
* *MUST* support registering the same listener for multiple address patterns
* *MUST* document the maximum supported number of listeners per address pattern.
* *MUST* fail with a `UCode::RESOURCE_EXHAUSTED`, if the maximum number of listeners is reached
--

=== UnregisterListener

Clients use this method to unregister a previously registered listener.
The listener will no longer be called for any (matching) messages after this method has returned successfully.

[source]
----
unregisterListener(
  IN sourceFilter: UUri,
  IN sinkFilter: UUri?,
  IN listener: UListener&,
  OUT result: Future<Void, UStatus>
)
----

.RegisterListener Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The source address pattern that the listener had been registered for.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The sink address pattern that the listener had been registered for.

| listener
| <<UListener>>
| The listener to be unregistered.

| result
| Future<Void, link:../basics/error_model.adoc[UStatus]>
| A succeeded future if the listener has been unregistered successfully. +
Otherwise, a failed future containing a `UStatus` indicating the reason for the failure.
|===


=== Receive

Clients use this method to receive a single message matching given filter criteria.
This method implements the _pull_ <<Delivery Method>> for the underlying messaging infrastructure.

[source]
----
receive(
  IN sourceFilter: UUri,
  IN sinkFilter: UUri?,
  OUT result: Future<UMessage&, UStatus>
)
----

.Receive Parameters
[width="100%",cols="15%,25%,60%"]
|===
|Parameter | Type | Description

| sourceFilter
| link:../basics/uri.adoc[UUri]
| The _source_ address pattern that messages need to match.

| sinkFilter
| link:../basics/uri.adoc[UUri]
| The _sink_ address pattern that messages need to match. If omitted, a message must not contain any sink address in order to match.

| result
| Future<Void, link:../basics/error_model.adoc[UStatus]>
| A succeeded future containing the least recent message that matches the given filter criteria and has not expired yet. +
A failed future if no message can be retrieved from the messaging infrastructure. The `UStatus` will contain a `UCode` indicating the reason for the failure.

|===

[oft-sid="req~utransport-register-listener~1"]
--
Implementations

* *MUST* fail with a `UCode::NOT_FOUND` if there are no matching messages available
--

=== Message Delivery

==== Policy

* uTransport `send()` API *MUST* support, meaning the caller of this API is guaranteed the message was successfully delivered to the next-hop only. End-2-end delivery, when messages are sent across multiple transports, is *not* guaranteed by the transport layer
* Transport *MUST* support retransmission of messages that are no able to be delivered to the next-hop

If the uP-L1 transport layer is above https://en.wikipedia.org/wiki/OSI_model[OSI Session layer 5]:

* *MUST* use Transmission Control Protocols (TCP) and *SHOULD NOT* User Datagram Protocol (UDP) for message delivery, this is to ensure https://www.cloudcomputingpatterns.org/at_least_once_delivery/[At-least-once delivery] of messages

==== Delivery Method

* Transport *MUST* support either _push_ or _pull_ delivery method
* *MAY* support both _push_ or _pull_ delivery methods between uEs
* Delivery method *SHOULD* be known by uEs at design time
* Receivers *MAY* select which delivery method they prefer if the transport between sender and receiver supports more than one delivery method

NOTE: Delivery method advertising shall be defined later


== Transport Specifics

Below is an non-exhaustive list of transport specific requirements to ensure consistency across implementations of the same or different languages:

* link:binder.adoc[*Android Binder*]
* link:zenoh.adoc[*Eclipse Zenoh*]
* link:ecal.adoc[*Eclipse ECAL*]
* link:p3comm.adoc[*Eclipse P3Comm*]
* link:mqtt.adoc[*MQTT*]
* link:http.adoc[*HTTP*]
* link:someip/README.adoc[*SOME/IP*]

Implementers of `UTransport` *MAY* choose to employ link:https://cloudevents.io/[CloudEvents] as a means to map UMessages to the underlying transport's Packet Data Unit (PDU). In order to provide for consistency across implementations, such transport implementations *MUST* adhere to

* link:cloudevents.adoc[*UMessage mapping to CloudEvents*]
